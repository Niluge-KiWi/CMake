/*============================================================================
  CMake - Cross Platform Makefile Generator
  Copyright 2004-2009 Kitware, Inc.
  Copyright 2004 Alexander Neundorf (neundorf@kde.org)
  Copyright 2012 Thomas Riccardi (riccardi.thomas@gmail.com)

  Distributed under the OSI-approved BSD License (the "License");
  see accompanying file Copyright.txt for details.

  This software is distributed WITHOUT ANY WARRANTY; without even the
  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  See the License for more information.
============================================================================*/
#include "cmExtraEDEGenerator.h"
#include "cmGlobalUnixMakefileGenerator3.h"
#include "cmLocalUnixMakefileGenerator3.h"
#include "cmMakefile.h"
#include "cmake.h"
#include "cmSourceFile.h"
#include "cmGeneratedFileStream.h"
#include "cmTarget.h"
#include "cmSystemTools.h"
#include "cmXMLSafe.h"

#include <cmsys/SystemTools.hxx>

// TMP
#include <iostream>


//----------------------------------------------------------------------------
void cmExtraEDEGenerator
::GetDocumentation(cmDocumentationEntry& entry, const char*) const
{
  entry.Name = this->GetName();
  entry.Brief = "Generates EDE project files.";
  entry.Full =
    "Project files for EDE will be created in the top directory "
    "and in every subdirectory which features a CMakeLists.txt file "
    "containing a PROJECT() call. "
    "Additional EDE files will be created for each CMakeLists.txt files."
    "Additionally a hierarchy of makefiles is generated into the "
    "build tree.  The appropriate make program can build the project through "
    "the default make target.  A \"make install\" target is also provided.";
}

cmExtraEDEGenerator::cmExtraEDEGenerator()
:cmExternalMakefileProjectGenerator()
{
#if defined(_WIN32)
// disable until somebody actually tests it:
//  this->SupportedGlobalGenerators.push_back("MinGW Makefiles");
//  this->SupportedGlobalGenerators.push_back("NMake Makefiles");
//  this->SupportedGlobalGenerators.push_back("MSYS Makefiles");
#endif
  this->SupportedGlobalGenerators.push_back("Unix Makefiles");
}


void cmExtraEDEGenerator::Generate()
{
  // for each sub project in the project create a codeblocks project
  for (std::map<cmStdString, std::vector<cmLocalGenerator*> >::const_iterator
      it = this->GlobalGenerator->GetProjectMap().begin();
      it!= this->GlobalGenerator->GetProjectMap().end();
      ++it)
    {
    //TMP
    std::cout << "Project: " << it->first << std::endl;
    // create a project file
    this->CreateProjectFile(it->second);
    }

  for (std::vector<cmLocalGenerator*>::const_iterator
       it = this->GlobalGenerator->GetLocalGenerators().begin();
       it!= this->GlobalGenerator->GetLocalGenerators().end();
       ++it)
    {
    //TMP
    std::cout << std::endl;
    std::cout << "---------------" << std::endl;
    std::cout << "LocalGenerator: " << (*it)->GetRelativeRootPath(cmLocalGenerator::START) << std::endl;
    (*it)->GetMakefile()->Print();
    // create an EDE local generator file
    this->CreateLocalGeneratorFile(*it);
    }
}

/* create the local generator file */
void cmExtraEDEGenerator::CreateLocalGeneratorFile(cmLocalGenerator* lg)
{
  const cmMakefile* mf=lg->GetMakefile();
  std::string outputDir=mf->GetStartOutputDirectory();

  std::string filename=outputDir+"/ede.local.generator.el";

  this->CreateNewLocalGeneratorFile(lg, filename);
}


void cmExtraEDEGenerator::CreateNewLocalGeneratorFile(cmLocalGenerator* lg,
  const std::string& filename)
{
  const cmMakefile* mf=lg->GetMakefile();
  std::string projectName=mf->GetProjectName();
  cmGeneratedFileStream fout(filename.c_str());
  if(!fout)
    {
    return;
    }

  fout<<";; EDE local generator file\n"
    ";; Generated by CMake EDE Generator\n"
    "\n"
    "((project . \""<<projectName<<"\")\n"
    " (include-dirs . '(";
  std::vector<std::string> dirs;
  //TODO lang? currently only used for CMAKE[C|CXX]_IMPLICIT_INCLUDE_DIRECTORIES
  lg->GetIncludeDirectories(dirs);
  for(std::vector<std::string>::const_iterator it=dirs.begin();
      it!=dirs.end();
      ++it)
    {
    fout<<"\""<<*it<<"\" ";
    }
  fout<<"))\n";
  std::string startPath=lg->GetRelativeRootPath(cmLocalGenerator::START);
  std::string startOutputPath=
    lg->GetRelativeRootPath(cmLocalGenerator::START_OUTPUT);
  fout<<" (start-dir . \""<<startPath<<"\")\n"
    " (start-output-dir . \""<<startOutputPath<<"\")";
  //TODO configurations?
  //mf->GetConfigurations()
  //TODO targets
  //cmTargets& targets=mf->GetTargets();
  //TODO defineflags
  //std::string defineFlags=mf->GetDefineFlags();
      
  fout<<")\n";

}

/* create the project file */
void cmExtraEDEGenerator::CreateProjectFile(
                                     const std::vector<cmLocalGenerator*>& lgs)
{
  const cmMakefile* mf=lgs[0]->GetMakefile();
  std::string outputDir=mf->GetStartOutputDirectory();
  std::string projectName=mf->GetProjectName();

  std::string filename=outputDir+"/";
  filename+=projectName+".ede";

  this->CreateNewProjectFile(lgs, filename);
}

void cmExtraEDEGenerator
  ::CreateNewProjectFile(const std::vector<cmLocalGenerator*>& lgs,
                         const std::string& filename)
{
  const cmMakefile* mf=lgs[0]->GetMakefile();
  cmGeneratedFileStream fout(filename.c_str());
  if(!fout)
    {
    return;
    }

  std::string projectName=mf->GetProjectName();
  fout<<";; EDE project file\n"
    ";; Generated by CMake EDE Generator\n"
    "\n"
    "((project . \""<<projectName<<"\")\n"
    " (local-generators . '(";
  std::set<std::string> subProjects;
  for(std::vector<cmLocalGenerator*>::const_iterator it=lgs.begin();
      it!=lgs.end();
      ++it)
    {
      if((*it)->GetMakefile()->GetProjectName()!=projectName)
        {
        // this is a subproject
        //TODO store root path
        subProjects.insert((*it)->GetMakefile()->GetProjectName());
        continue;
        }
    std::string startOutputPath=
      (*it)->GetRelativeRootPath(cmLocalGenerator::START_OUTPUT);
    fout<<"\""<<startOutputPath<<"\" ";
    }
  fout<<"))\n"
    " (sub-projects '(";
  for(std::set<std::string>::const_iterator it=subProjects.begin();
      it!=subProjects.end();
      ++it)
    {
    fout<<"\""<<*it<<"\" ";
    }
  fout<<"))";

  fout<<")\n";
}
